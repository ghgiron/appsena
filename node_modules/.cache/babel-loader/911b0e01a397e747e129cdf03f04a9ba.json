{"ast":null,"code":"import isPlainObject from 'lodash.isplainobject';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport get from 'lodash.get';\nimport has from 'lodash.has';\nimport set from 'lodash.set';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n\nfunction isObject(value) {\n  return isPlainObject(value);\n}\n\nfunction isTypeUndefined(value) {\n  return typeof value === 'undefined';\n}\n\nfunction isDate(value) {\n  return value instanceof Date;\n}\n\nfunction isFunction(value) {\n  return value !== null && typeof value === 'function';\n}\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n\nfunction isRegex(value) {\n  return value instanceof RegExp;\n}\n\nfunction isValueStringEmpty(value) {\n  return value === '';\n}\n\nfunction isValueNullOrUndefined(value) {\n  return value === null || value === undefined;\n}\n\nfunction isValueUndefined(value) {\n  return value === undefined;\n}\n\nfunction noop() {// do nothing.\n}\n\nfunction protectAgainstParamReassignment(value) {\n  // Clone objects to avoid accidental param reassignment\n  if (isObject(value)) return _extends({}, value);\n  if (isArray(value)) return [].concat(value);\n  return value;\n}\n\nfunction isSame(a, b) {\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    return a.every(function (item, index) {\n      return isSame(item, b[index]);\n    });\n  }\n\n  if (isFunction(a) && isFunction(b)) {\n    return a.toString() === b.toString();\n  }\n\n  if (isDate(a) && isDate(b)) {\n    return a.toString() === b.toString();\n  }\n\n  if (isObject(a) && isObject(b)) {\n    if (Object.keys(a).length !== Object.keys(b).length) {\n      return false;\n    }\n\n    return Object.keys(a).every(function (key) {\n      return isSame(a[key], b[key]);\n    });\n  }\n\n  if (isRegex(a) && isRegex(b)) {\n    return a.toString() === b.toString();\n  }\n\n  return a === b;\n}\n\nfunction runRules(value, currentValues, validations, validationRules) {\n  var results = {\n    errors: [],\n    failed: [],\n    success: []\n  };\n  Object.keys(validations).forEach(function (validationName) {\n    var validationsVal = validations[validationName];\n    var validationRulesVal = validationRules[validationName];\n\n    var addToResults = function addToResults(validation) {\n      if (isString(validation)) {\n        results.errors.push(validation);\n        results.failed.push(validationName);\n      } else if (!validation) {\n        results.failed.push(validationName);\n      } else {\n        results.success.push(validationName);\n      }\n    };\n\n    if (validationRulesVal && isFunction(validationsVal)) {\n      throw new Error(\"Formsy does not allow you to override default validations: \" + validationName);\n    }\n\n    if (!validationRulesVal && !isFunction(validationsVal)) {\n      throw new Error(\"Formsy does not have the validation rule: \" + validationName);\n    }\n\n    if (isFunction(validationsVal)) {\n      return addToResults(validationsVal(currentValues, value));\n    }\n\n    return addToResults(validationRulesVal(currentValues, value, validationsVal));\n  });\n  return results;\n}\n\nfunction throttle(callback, interval) {\n  var enableCall = true;\n  return function () {\n    if (!enableCall) return;\n    enableCall = false;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n    setTimeout(function () {\n      return enableCall = true;\n    }, interval);\n  };\n}\n\nfunction _isExisty(value) {\n  return !isValueNullOrUndefined(value);\n}\n\nfunction isEmpty(value) {\n  if (isString(value)) {\n    return isValueStringEmpty(value);\n  }\n\n  if (isTypeUndefined(value)) {\n    return false;\n  }\n\n  return isValueUndefined(value);\n}\n\nfunction _isDefaultRequiredValue(value) {\n  return isString(value) ? isValueStringEmpty(value) : isValueNullOrUndefined(value);\n}\n\nfunction matchRegexp(_values, value, regexp) {\n  return !_isExisty(value) || isEmpty(value) || regexp.test(\"\" + value);\n}\n\nvar REGEX_PATTERNS = {\n  ALPHA: /^[A-Z]+$/i,\n  ALPHANUMERIC: /^[0-9A-Z]+$/i,\n  EMAIL: /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/i,\n  FLOAT: /^(?:[-+]?(?:\\d+))?(?:\\.\\d*)?(?:[eE][+-]?(?:\\d+))?$/,\n  INT: /^(?:[-+]?(?:0|[1-9]\\d*))$/,\n  NUMERIC: /^[-+]?(?:\\d*[.])?\\d+$/,\n  SPECIAL_WORDS: /^[\\sA-ZÀ-ÖØ-öø-ÿ]+$/i,\n  URL: /^(?:\\w+:)?\\/\\/([^\\s.]+\\.\\S{2}|localhost[:?\\d]*)\\S*$/i,\n  WORDS: /^[A-Z\\s]+$/i\n};\nvar validations = {\n  equals: function equals(_values, value, eql) {\n    return !_isExisty(value) || isEmpty(value) || value === eql;\n  },\n  equalsField: function equalsField(values, value, field) {\n    return value === values[field];\n  },\n  isAlpha: function isAlpha(values, value) {\n    return matchRegexp(values, value, REGEX_PATTERNS.ALPHA);\n  },\n  isAlphanumeric: function isAlphanumeric(values, value) {\n    return matchRegexp(values, value, REGEX_PATTERNS.ALPHANUMERIC);\n  },\n  isDefaultRequiredValue: function isDefaultRequiredValue(_values, value) {\n    return _isDefaultRequiredValue(value);\n  },\n  isEmail: function isEmail(values, value) {\n    return matchRegexp(values, value, REGEX_PATTERNS.EMAIL);\n  },\n  isEmptyString: function isEmptyString(_values, value) {\n    return isEmpty(value);\n  },\n  isExisty: function isExisty(_values, value) {\n    return _isExisty(value);\n  },\n  isFalse: function isFalse(_values, value) {\n    return value === false;\n  },\n  isFloat: function isFloat(values, value) {\n    return matchRegexp(values, value, REGEX_PATTERNS.FLOAT);\n  },\n  isInt: function isInt(values, value) {\n    return matchRegexp(values, value, REGEX_PATTERNS.INT);\n  },\n  isLength: function isLength(_values, value, length) {\n    return !_isExisty(value) || isEmpty(value) || value.length === length;\n  },\n  isNumeric: function isNumeric(values, value) {\n    return isNumber(value) || matchRegexp(values, value, REGEX_PATTERNS.NUMERIC);\n  },\n  isSpecialWords: function isSpecialWords(values, value) {\n    return matchRegexp(values, value, REGEX_PATTERNS.SPECIAL_WORDS);\n  },\n  isTrue: function isTrue(_values, value) {\n    return value === true;\n  },\n  isUndefined: function isUndefined(_values, value) {\n    return isValueUndefined(value);\n  },\n  isUrl: function isUrl(values, value) {\n    return matchRegexp(values, value, REGEX_PATTERNS.URL);\n  },\n  isWords: function isWords(values, value) {\n    return matchRegexp(values, value, REGEX_PATTERNS.WORDS);\n  },\n  matchRegexp: matchRegexp,\n  maxLength: function maxLength(_values, value, length) {\n    return !_isExisty(value) || value.length <= length;\n  },\n  minLength: function minLength(_values, value, length) {\n    return !_isExisty(value) || isEmpty(value) || value.length >= length;\n  }\n};\n\nvar addValidationRule = function addValidationRule(name, func) {\n  validations[name] = func;\n};\n\nvar noFormsyErrorMessage = 'Could not find Formsy Context Provider. Did you use withFormsy outside <Formsy />?';\n\nvar throwNoFormsyProvider = function throwNoFormsyProvider() {\n  // istanbul ignore next\n  throw new Error(noFormsyErrorMessage);\n};\n\nvar defaultValue = {\n  attachToForm: throwNoFormsyProvider,\n  detachFromForm: throwNoFormsyProvider,\n  isFormDisabled: true,\n  isValidValue: throwNoFormsyProvider,\n  validate: throwNoFormsyProvider,\n  runValidation: throwNoFormsyProvider\n};\nvar FormsyContext = /*#__PURE__*/React.createContext(defaultValue);\n/* eslint-disable react/default-props-match-prop-types */\n\nvar convertValidationsToObject = function convertValidationsToObject(validations) {\n  if (isString(validations)) {\n    return validations.split(/,(?![^{[]*[}\\]])/g).reduce(function (validationsAccumulator, validation) {\n      var args = validation.split(':');\n      var validateMethod = args.shift();\n      args = args.map(function (arg) {\n        try {\n          return JSON.parse(arg);\n        } catch (e) {\n          return arg; // It is a string if it can not parse it\n        }\n      });\n\n      if (args.length > 1) {\n        throw new Error('Formsy does not support multiple args on string validations. Use object format of validations instead.');\n      } // Avoid parameter reassignment\n\n\n      var validationsAccumulatorCopy = _extends({}, validationsAccumulator);\n\n      validationsAccumulatorCopy[validateMethod] = args.length ? args[0] : true;\n      return validationsAccumulatorCopy;\n    }, {});\n  }\n\n  return validations || {};\n};\n\nvar propTypes = {\n  innerRef: PropTypes.func,\n  name: PropTypes.string.isRequired,\n  required: /*#__PURE__*/PropTypes.oneOfType([PropTypes.bool, PropTypes.object, PropTypes.string]),\n  validations: /*#__PURE__*/PropTypes.oneOfType([PropTypes.object, PropTypes.string]),\n  value: PropTypes.any\n};\n\nfunction getDisplayName(component) {\n  return component.displayName || component.name || (isString(component) ? component : 'Component');\n}\n\nfunction withFormsy(WrappedComponent) {\n  var WithFormsyWrapper = /*#__PURE__*/function (_React$Component) {\n    _inheritsLoose(WithFormsyWrapper, _React$Component);\n\n    function WithFormsyWrapper(props) {\n      var _this;\n\n      _this = _React$Component.call(this, props) || this;\n\n      _this.getErrorMessage = function () {\n        var messages = _this.getErrorMessages();\n\n        return messages.length ? messages[0] : null;\n      };\n\n      _this.getErrorMessages = function () {\n        var validationError = _this.state.validationError;\n\n        if (!_this.isValid() || _this.showRequired()) {\n          return validationError || [];\n        }\n\n        return [];\n      }; // eslint-disable-next-line react/destructuring-assignment\n\n\n      _this.getValue = function () {\n        return _this.state.value;\n      };\n\n      _this.setValidations = function (validations, required) {\n        // Add validations to the store itself as the props object can not be modified\n        _this.validations = convertValidationsToObject(validations) || {};\n        _this.requiredValidations = required === true ? {\n          isDefaultRequiredValue: required\n        } : convertValidationsToObject(required);\n      }; // By default, we validate after the value has been set.\n      // A user can override this and pass a second parameter of `false` to skip validation.\n\n\n      _this.setValue = function (value, validate) {\n        if (validate === void 0) {\n          validate = true;\n        }\n\n        var validateForm = _this.props.validate;\n\n        if (!validate) {\n          _this.setState({\n            value: value\n          });\n        } else {\n          _this.setState({\n            value: value,\n            isPristine: false\n          }, function () {\n            validateForm(_assertThisInitialized(_this));\n          });\n        }\n      }; // eslint-disable-next-line react/destructuring-assignment\n\n\n      _this.hasValue = function () {\n        var value = _this.state.value;\n        return _isDefaultRequiredValue(value);\n      }; // eslint-disable-next-line react/destructuring-assignment\n\n\n      _this.isFormDisabled = function () {\n        return _this.props.isFormDisabled;\n      }; // eslint-disable-next-line react/destructuring-assignment\n\n\n      _this.isFormSubmitted = function () {\n        return _this.state.formSubmitted;\n      }; // eslint-disable-next-line react/destructuring-assignment\n\n\n      _this.isPristine = function () {\n        return _this.state.isPristine;\n      }; // eslint-disable-next-line react/destructuring-assignment\n\n\n      _this.isRequired = function () {\n        return !!_this.props.required;\n      }; // eslint-disable-next-line react/destructuring-assignment\n\n\n      _this.isValid = function () {\n        return _this.state.isValid;\n      }; // eslint-disable-next-line react/destructuring-assignment\n\n\n      _this.isValidValue = function (value) {\n        return _this.props.isValidValue(_assertThisInitialized(_this), value);\n      };\n\n      _this.resetValue = function () {\n        var pristineValue = _this.state.pristineValue;\n        var validate = _this.props.validate;\n\n        _this.setState({\n          value: pristineValue,\n          isPristine: true\n        }, function () {\n          validate(_assertThisInitialized(_this));\n        });\n      };\n\n      _this.showError = function () {\n        return !_this.showRequired() && !_this.isValid();\n      }; // eslint-disable-next-line react/destructuring-assignment\n\n\n      _this.showRequired = function () {\n        return _this.state.isRequired;\n      };\n\n      var runValidation = props.runValidation,\n          validations = props.validations,\n          required = props.required,\n          value = props.value;\n      _this.state = {\n        value: value\n      };\n\n      _this.setValidations(validations, required);\n\n      _this.state = _extends({\n        formSubmitted: false,\n        isPristine: true,\n        pristineValue: props.value,\n        value: props.value\n      }, runValidation(_assertThisInitialized(_this), props.value));\n      return _this;\n    }\n\n    var _proto = WithFormsyWrapper.prototype;\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props = this.props,\n          name = _this$props.name,\n          attachToForm = _this$props.attachToForm;\n\n      if (!name) {\n        throw new Error('Form Input requires a name property when used');\n      }\n\n      attachToForm(this);\n    };\n\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      var props = this.props,\n          state = this.state;\n\n      var isChanged = function isChanged(a, b) {\n        return Object.keys(a).some(function (k) {\n          return a[k] !== b[k];\n        });\n      };\n\n      var isPropsChanged = isChanged(props, nextProps);\n      var isStateChanged = isChanged(state, nextState);\n      return isPropsChanged || isStateChanged;\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n      var _this$props2 = this.props,\n          value = _this$props2.value,\n          validations = _this$props2.validations,\n          required = _this$props2.required,\n          validate = _this$props2.validate; // If the value passed has changed, set it. If value is not passed it will\n      // internally update, and this will never run\n\n      if (!isSame(value, prevProps.value)) {\n        this.setValue(value);\n      } // If validations or required is changed, run a new validation\n\n\n      if (!isSame(validations, prevProps.validations) || !isSame(required, prevProps.required)) {\n        this.setValidations(validations, required);\n        validate(this);\n      }\n    } // Detach it when component unmounts\n    ;\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      var detachFromForm = this.props.detachFromForm;\n      detachFromForm(this);\n    };\n\n    _proto.render = function render() {\n      var innerRef = this.props.innerRef;\n\n      var propsForElement = _extends({}, this.props, {\n        errorMessage: this.getErrorMessage(),\n        errorMessages: this.getErrorMessages(),\n        hasValue: this.hasValue(),\n        isFormDisabled: this.isFormDisabled(),\n        isFormSubmitted: this.isFormSubmitted(),\n        isPristine: this.isPristine(),\n        isRequired: this.isRequired(),\n        isValid: this.isValid(),\n        isValidValue: this.isValidValue,\n        resetValue: this.resetValue,\n        setValidations: this.setValidations,\n        setValue: this.setValue,\n        showError: this.showError(),\n        showRequired: this.showRequired(),\n        value: this.getValue()\n      });\n\n      if (innerRef) {\n        propsForElement.ref = innerRef;\n      }\n\n      return React.createElement(WrappedComponent, propsForElement);\n    };\n\n    return WithFormsyWrapper;\n  }(React.Component);\n\n  WithFormsyWrapper.displayName = \"Formsy(\" + getDisplayName(WrappedComponent) + \")\";\n  WithFormsyWrapper.propTypes = propTypes;\n  WithFormsyWrapper.defaultProps = {\n    innerRef: null,\n    required: false,\n    validationError: '',\n    validationErrors: {},\n    validations: null,\n    value: WrappedComponent.defaultValue\n  }; // eslint-disable-next-line react/display-name\n\n  return function (props) {\n    return React.createElement(FormsyContext.Consumer, null, function (contextValue) {\n      return React.createElement(WithFormsyWrapper, _extends({}, props, contextValue));\n    });\n  };\n}\n\nvar ONE_RENDER_FRAME = 66;\n\nvar Formsy = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Formsy, _React$Component);\n\n  function Formsy(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.prevInputNames = null;\n\n    _this.componentDidMount = function () {\n      _this.prevInputNames = _this.inputs.map(function (component) {\n        return component.props.name;\n      });\n\n      _this.validateForm();\n    };\n\n    _this.componentDidUpdate = function (prevProps) {\n      var _this$props = _this.props,\n          validationErrors = _this$props.validationErrors,\n          disabled = _this$props.disabled;\n\n      if (validationErrors && isObject(validationErrors) && Object.keys(validationErrors).length > 0) {\n        _this.setInputValidationErrors(validationErrors);\n      }\n\n      var newInputNames = _this.inputs.map(function (component) {\n        return component.props.name;\n      });\n\n      if (_this.prevInputNames && !isSame(_this.prevInputNames, newInputNames)) {\n        _this.prevInputNames = newInputNames;\n\n        _this.validateForm();\n      } // Keep the disabled value in state/context the same as from props\n\n\n      if (disabled !== prevProps.disabled) {\n        // eslint-disable-next-line\n        _this.setState(function (state) {\n          return _extends({}, state, {\n            contextValue: _extends({}, state.contextValue, {\n              isFormDisabled: disabled\n            })\n          });\n        });\n      }\n    };\n\n    _this.getCurrentValues = function () {\n      return _this.inputs.reduce(function (valueAccumulator, component) {\n        var name = component.props.name,\n            value = component.state.value; // eslint-disable-next-line no-param-reassign\n\n        valueAccumulator[name] = protectAgainstParamReassignment(value);\n        return valueAccumulator;\n      }, {});\n    };\n\n    _this.getModel = function () {\n      var currentValues = _this.getCurrentValues();\n\n      return _this.mapModel(currentValues);\n    };\n\n    _this.getPristineValues = function () {\n      return _this.inputs.reduce(function (valueAccumulator, component) {\n        var _component$props = component.props,\n            name = _component$props.name,\n            value = _component$props.value; // eslint-disable-next-line no-param-reassign\n\n        valueAccumulator[name] = protectAgainstParamReassignment(value);\n        return valueAccumulator;\n      }, {});\n    };\n\n    _this.setFormPristine = function (isPristine) {\n      _this.setState({\n        formSubmitted: !isPristine\n      }); // Iterate through each component and set it as pristine\n      // or \"dirty\".\n\n\n      _this.inputs.forEach(function (component) {\n        component.setState({\n          formSubmitted: !isPristine,\n          isPristine: isPristine\n        });\n      });\n    };\n\n    _this.setInputValidationErrors = function (errors) {\n      var preventExternalInvalidation = _this.props.preventExternalInvalidation;\n      var isValid = _this.state.isValid;\n\n      _this.inputs.forEach(function (component) {\n        var name = component.props.name;\n        component.setState({\n          isValid: !(name in errors),\n          validationError: isString(errors[name]) ? [errors[name]] : errors[name]\n        });\n      });\n\n      if (!preventExternalInvalidation && isValid) {\n        _this.setFormValidState(false);\n      }\n    };\n\n    _this.setFormValidState = function (allIsValid) {\n      var _this$props2 = _this.props,\n          onValid = _this$props2.onValid,\n          onInvalid = _this$props2.onInvalid;\n\n      _this.setState({\n        isValid: allIsValid\n      });\n\n      if (allIsValid) {\n        onValid();\n      } else {\n        onInvalid();\n      }\n    };\n\n    _this.isValidValue = function (component, value) {\n      return _this.runValidation(component, value).isValid;\n    }; // eslint-disable-next-line react/destructuring-assignment\n\n\n    _this.isFormDisabled = function () {\n      return _this.props.disabled;\n    };\n\n    _this.mapModel = function (model) {\n      var mapping = _this.props.mapping;\n\n      if (mapping) {\n        return mapping(model);\n      }\n\n      var returnModel = {};\n      Object.keys(model).forEach(function (key) {\n        set(returnModel, key, model[key]);\n      });\n      return returnModel;\n    };\n\n    _this.reset = function (model) {\n      _this.setFormPristine(true);\n\n      _this.resetModel(model);\n    };\n\n    _this.resetInternal = function (event) {\n      var onReset = _this.props.onReset;\n      event.preventDefault();\n\n      _this.reset();\n\n      if (onReset) {\n        onReset();\n      }\n    }; // Reset each key in the model to the original / initial / specified value\n\n\n    _this.resetModel = function (data) {\n      _this.inputs.forEach(function (component) {\n        var name = component.props.name;\n\n        if (data && has(data, name)) {\n          component.setValue(get(data, name));\n        } else {\n          component.resetValue();\n        }\n      });\n\n      _this.validateForm();\n    }; // Checks validation on current value or a passed value\n\n\n    _this.runValidation = function (component, value) {\n      if (value === void 0) {\n        value = component.state.value;\n      }\n\n      var validationErrors = _this.props.validationErrors;\n      var _component$props2 = component.props,\n          validationError = _component$props2.validationError,\n          componentValidationErrors = _component$props2.validationErrors,\n          name = _component$props2.name;\n\n      var currentValues = _this.getCurrentValues();\n\n      var validationResults = runRules(value, currentValues, component.validations, validations);\n      var requiredResults = runRules(value, currentValues, component.requiredValidations, validations);\n      var isRequired = Object.keys(component.requiredValidations).length ? !!requiredResults.success.length : false;\n      var isValid = !validationResults.failed.length && !(validationErrors && validationErrors[component.props.name]);\n      return {\n        isRequired: isRequired,\n        isValid: isRequired ? false : isValid,\n        validationError: function () {\n          if (isValid && !isRequired) {\n            return _this.emptyArray;\n          }\n\n          if (validationResults.errors.length) {\n            return validationResults.errors;\n          }\n\n          if (validationErrors && validationErrors[name]) {\n            return isString(validationErrors[name]) ? [validationErrors[name]] : validationErrors[name];\n          }\n\n          if (isRequired) {\n            var error = componentValidationErrors[requiredResults.success[0]] || validationError;\n            return error ? [error] : null;\n          }\n\n          if (validationResults.failed.length) {\n            return validationResults.failed.map(function (failed) {\n              return componentValidationErrors[failed] ? componentValidationErrors[failed] : validationError;\n            }).filter(function (x, pos, arr) {\n              return arr.indexOf(x) === pos;\n            }); // remove duplicates\n          } // This line is not reachable\n          // istanbul ignore next\n\n\n          return undefined;\n        }()\n      };\n    }; // Method put on each input component to register\n    // itself to the form\n\n\n    _this.attachToForm = function (component) {\n      if (_this.inputs.indexOf(component) === -1) {\n        _this.inputs.push(component);\n      }\n\n      var onChange = _this.props.onChange;\n      var canChange = _this.state.canChange; // Trigger onChange\n\n      if (canChange) {\n        onChange(_this.getModel(), _this.isChanged());\n      } // Will be triggered immediately & every one frame rate\n\n\n      _this.throttledValidateForm();\n    }; // Method put on each input component to unregister\n    // itself from the form\n\n\n    _this.detachFromForm = function (component) {\n      var componentPos = _this.inputs.indexOf(component);\n\n      if (componentPos !== -1) {\n        _this.inputs = _this.inputs.slice(0, componentPos).concat(_this.inputs.slice(componentPos + 1));\n      }\n\n      _this.validateForm();\n    }; // Checks if the values have changed from their initial value\n\n\n    _this.isChanged = function () {\n      return !isSame(_this.getPristineValues(), _this.getCurrentValues());\n    }; // Update model, submit to url prop and send the model\n\n\n    _this.submit = function (event) {\n      var _this$props3 = _this.props,\n          onSubmit = _this$props3.onSubmit,\n          onValidSubmit = _this$props3.onValidSubmit,\n          onInvalidSubmit = _this$props3.onInvalidSubmit,\n          preventDefaultSubmit = _this$props3.preventDefaultSubmit;\n      var isValid = _this.state.isValid;\n\n      if (preventDefaultSubmit && event && event.preventDefault) {\n        event.preventDefault();\n      } // Trigger form as not pristine.\n      // If any inputs have not been touched yet this will make them dirty\n      // so validation becomes visible (if based on isPristine)\n\n\n      _this.setFormPristine(false);\n\n      var model = _this.getModel();\n\n      onSubmit(model, _this.resetModel, _this.updateInputsWithError, event);\n\n      if (isValid) {\n        onValidSubmit(model, _this.resetModel, _this.updateInputsWithError, event);\n      } else {\n        onInvalidSubmit(model, _this.resetModel, _this.updateInputsWithError, event);\n      }\n    }; // Go through errors from server and grab the components\n    // stored in the inputs map. Change their state to invalid\n    // and set the serverError message\n\n\n    _this.updateInputsWithError = function (errors, invalidate) {\n      var preventExternalInvalidation = _this.props.preventExternalInvalidation;\n      var isValid = _this.state.isValid;\n      Object.entries(errors).forEach(function (_ref) {\n        var name = _ref[0],\n            error = _ref[1];\n\n        var component = _this.inputs.find(function (input) {\n          return input.props.name === name;\n        });\n\n        if (!component) {\n          throw new Error(\"You are trying to update an input that does not exist. Verify errors object with input names. \" + JSON.stringify(errors));\n        }\n\n        component.setState({\n          isValid: preventExternalInvalidation,\n          validationError: isString(error) ? [error] : error\n        });\n      });\n\n      if (invalidate && isValid) {\n        _this.setFormValidState(false);\n      }\n    }; // Set the value of components\n\n\n    _this.updateInputsWithValue = function (values, validate) {\n      Object.entries(values).forEach(function (_ref2) {\n        var name = _ref2[0],\n            value = _ref2[1];\n\n        var input = _this.inputs.find(function (component) {\n          return component.props.name === name;\n        });\n\n        if (input) {\n          input.setValue(value, validate);\n        }\n      });\n    }; // Use the binded values and the actual input value to\n    // validate the input and set its state. Then check the\n    // state of the form itself\n\n\n    _this.validate = function (component) {\n      var onChange = _this.props.onChange;\n      var canChange = _this.state.canChange; // Trigger onChange\n\n      if (canChange) {\n        onChange(_this.getModel(), _this.isChanged());\n      }\n\n      var validationState = _this.runValidation(component); // Run through the validations, split them up and call\n      // the validator IF there is a value or it is required\n\n\n      component.setState(validationState, _this.validateForm);\n    }; // Validate the form by going through all child input components\n    // and check their state\n\n\n    _this.validateForm = function () {\n      // We need a callback as we are validating all inputs again. This will\n      // run when the last component has set its state\n      var onValidationComplete = function onValidationComplete() {\n        var allIsValid = _this.inputs.every(function (component) {\n          return component.state.isValid;\n        });\n\n        _this.setFormValidState(allIsValid); // Tell the form that it can start to trigger change events\n\n\n        _this.setState({\n          canChange: true\n        });\n      }; // Run validation again in case affected by other inputs. The\n      // last component validated will run the onValidationComplete callback\n\n\n      _this.inputs.forEach(function (component, index) {\n        var validationState = _this.runValidation(component);\n\n        var isFinalInput = index === _this.inputs.length - 1;\n        var callback = isFinalInput ? onValidationComplete : null;\n        component.setState(validationState, callback);\n      }); // If there are no inputs, set state where form is ready to trigger\n      // change event. New inputs might be added later\n\n\n      if (!_this.inputs.length) {\n        _this.setState({\n          canChange: true\n        }, onValidationComplete);\n      }\n    };\n\n    _this.state = {\n      canChange: false,\n      isSubmitting: false,\n      isValid: true,\n      contextValue: {\n        attachToForm: _this.attachToForm,\n        detachFromForm: _this.detachFromForm,\n        isFormDisabled: props.disabled,\n        isValidValue: _this.isValidValue,\n        validate: _this.validate,\n        runValidation: _this.runValidation\n      }\n    };\n    _this.inputs = [];\n    _this.emptyArray = [];\n    _this.throttledValidateForm = throttle(_this.validateForm, ONE_RENDER_FRAME);\n    return _this;\n  }\n\n  var _proto = Formsy.prototype;\n\n  _proto.render = function render() {\n    var _this$props4 = this.props,\n        children = _this$props4.children,\n        nonFormsyProps = _objectWithoutPropertiesLoose(_this$props4, [\"children\", \"mapping\", \"onChange\", \"onInvalid\", \"onInvalidSubmit\", \"onReset\", \"onSubmit\", \"onValid\", \"onValidSubmit\", \"preventDefaultSubmit\", \"preventExternalInvalidation\", \"validationErrors\"]);\n\n    var contextValue = this.state.contextValue;\n    return React.createElement(FormsyContext.Provider, {\n      value: contextValue\n    }, React.createElement('form', _extends({\n      onReset: this.resetInternal,\n      onSubmit: this.submit\n    }, nonFormsyProps, {\n      disabled: false\n    }), children));\n  };\n\n  return Formsy;\n}(React.Component);\n\nFormsy.displayName = 'Formsy';\nFormsy.propTypes = {\n  disabled: PropTypes.bool,\n  mapping: PropTypes.func,\n  onChange: PropTypes.func,\n  onInvalid: PropTypes.func,\n  onInvalidSubmit: PropTypes.func,\n  onReset: PropTypes.func,\n  onSubmit: PropTypes.func,\n  onValid: PropTypes.func,\n  onValidSubmit: PropTypes.func,\n  preventDefaultSubmit: PropTypes.bool,\n  preventExternalInvalidation: PropTypes.bool,\n  validationErrors: PropTypes.object\n};\nFormsy.defaultProps = {\n  disabled: false,\n  mapping: null,\n  onChange: noop,\n  onInvalid: noop,\n  onInvalidSubmit: noop,\n  onReset: noop,\n  onSubmit: noop,\n  onValid: noop,\n  onValidSubmit: noop,\n  preventDefaultSubmit: true,\n  preventExternalInvalidation: false,\n  validationErrors: {}\n};\nexport default Formsy;\nexport { addValidationRule, propTypes, validations as validationRules, withFormsy };","map":null,"metadata":{},"sourceType":"module"}